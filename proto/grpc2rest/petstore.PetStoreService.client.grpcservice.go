// This file registers with grpc service. This file was auto-generated by mashling at
	// 2018-12-05 14:10:42.144603605 -0700 MST m=+0.045548749
	package grpc2rest

	import (
		"context"
		
		"encoding/json"
		"github.com/project-flogo/grpc/support"
		
		"errors"
		
		"log"
		

		servInfo "github.com/project-flogo/grpc/activity"
		"google.golang.org/grpc"
	)
	
	
	
	type clientServicepetstorePetStoreServiceclient struct {
		serviceInfo *servInfo.ServiceInfo
	}

	var serviceInfopetstorePetStoreServiceclient = &servInfo.ServiceInfo{
		ProtoName: "petstore",
		ServiceName: "PetStoreService",
	}

	func init() {
		servInfo.ClientServiceRegistery.RegisterClientService(&clientServicepetstorePetStoreServiceclient{serviceInfo: serviceInfopetstorePetStoreServiceclient})
	}

	//GetRegisteredClientService returns client implimentaion stub with grpc connection
	func (cs *clientServicepetstorePetStoreServiceclient) GetRegisteredClientService(gCC *grpc.ClientConn) interface{} {
		return NewPetStoreServiceClient(gCC)
	}

	func (cs *clientServicepetstorePetStoreServiceclient) ServiceInfo() *servInfo.ServiceInfo {
		return cs.serviceInfo
	}

	func (cs *clientServicepetstorePetStoreServiceclient) InvokeMethod(reqArr map[string]interface{}) map[string]interface{} {

		clientObject := reqArr["ClientObject"].(PetStoreServiceClient)
		methodName := reqArr["MethodName"].(string)

		switch methodName {
		case "PetById":
			return PetById(clientObject, reqArr)
		case "UserByName":
			return UserByName(clientObject, reqArr)
		case "PetPUT":
			return PetPUT(clientObject, reqArr)
		case "UserPUT":
			return UserPUT(clientObject, reqArr)
		}

		resMap := make(map[string]interface{},2)
		resMap["Response"] = []byte("null")
		resMap["Error"] = errors.New("Method not Available: " + methodName)
		return resMap
	}
	func PetById(client PetStoreServiceClient, values interface{}) map[string]interface{} {
		req := &PetByIdRequest{}
		support.AssignStructValues(req, values)
		res, err := client.PetById(context.Background(), req)
		b, errMarshl := json.Marshal(res)
		if errMarshl != nil {
			log.Println("Error: ", errMarshl)
			return nil
		}

		resMap := make(map[string]interface{}, 2)
		resMap["Response"] = b
		resMap["Error"] = err
		return resMap
	}
	func UserByName(client PetStoreServiceClient, values interface{}) map[string]interface{} {
		req := &UserByNameRequest{}
		support.AssignStructValues(req, values)
		res, err := client.UserByName(context.Background(), req)
		b, errMarshl := json.Marshal(res)
		if errMarshl != nil {
			log.Println("Error: ", errMarshl)
			return nil
		}

		resMap := make(map[string]interface{}, 2)
		resMap["Response"] = b
		resMap["Error"] = err
		return resMap
	}
	func PetPUT(client PetStoreServiceClient, values interface{}) map[string]interface{} {
		req := &PetRequest{}
		support.AssignStructValues(req, values)
		res, err := client.PetPUT(context.Background(), req)
		b, errMarshl := json.Marshal(res)
		if errMarshl != nil {
			log.Println("Error: ", errMarshl)
			return nil
		}

		resMap := make(map[string]interface{}, 2)
		resMap["Response"] = b
		resMap["Error"] = err
		return resMap
	}
	func UserPUT(client PetStoreServiceClient, values interface{}) map[string]interface{} {
		req := &UserRequest{}
		support.AssignStructValues(req, values)
		res, err := client.UserPUT(context.Background(), req)
		b, errMarshl := json.Marshal(res)
		if errMarshl != nil {
			log.Println("Error: ", errMarshl)
			return nil
		}

		resMap := make(map[string]interface{}, 2)
		resMap["Response"] = b
		resMap["Error"] = err
		return resMap
	}

	