// This file registers with grpc service. This file was auto-generated by mashling at
	// 2019-05-17 12:26:08.827913713 +0530 IST m=+0.072356403
	package bidiproxygw

	import (
		"context"
		
		"errors"
		
		"strings"
		"io"
		
		"log"
		

		servInfo "github.com/project-flogo/grpc/activity"
		"google.golang.org/grpc"
	)
	
	
	
	type clientServicesamplebidiSampleServiceBidiclient struct {
		serviceInfo *servInfo.ServiceInfo
	}

	var serviceInfosamplebidiSampleServiceBidiclient = &servInfo.ServiceInfo{
		ProtoName: "samplebidi",
		ServiceName: "SampleServiceBidi",
	}

	func init() {
		servInfo.ClientServiceRegistery.RegisterClientService(&clientServicesamplebidiSampleServiceBidiclient{serviceInfo: serviceInfosamplebidiSampleServiceBidiclient})
	}

	//GetRegisteredClientService returns client implimentaion stub with grpc connection
	func (cs *clientServicesamplebidiSampleServiceBidiclient) GetRegisteredClientService(gCC *grpc.ClientConn) interface{} {
		return NewSampleServiceBidiClient(gCC)
	}

	func (cs *clientServicesamplebidiSampleServiceBidiclient) ServiceInfo() *servInfo.ServiceInfo {
		return cs.serviceInfo
	}

	func (cs *clientServicesamplebidiSampleServiceBidiclient) InvokeMethod(reqArr map[string]interface{}) map[string]interface{} {

		clientObject := reqArr["ClientObject"].(SampleServiceBidiClient)
		methodName := reqArr["MethodName"].(string)

		switch methodName {
		case "BidiStreaming":
			return BidiStreaming(clientObject, reqArr)
		}

		resMap := make(map[string]interface{},2)
		resMap["Response"] = []byte("null")
		resMap["Error"] = errors.New("Method not Available: " + methodName)
		return resMap
	}

	func BidiStreaming(client SampleServiceBidiClient, reqArr map[string]interface{}) map[string]interface{} {
		resMap := make(map[string]interface{}, 1)

		if reqArr["Mode"] != nil {
			mode := reqArr["Mode"].(string)
			if strings.Compare(mode,"rest-to-grpc") == 0 {
				resMap["Error"] = errors.New("streaming operation is not allowed in rest to grpc case")
				return resMap
			}
		}

		bReq := reqArr["strmReq"].(SampleServiceBidi_BidiStreamingServer)

		stream, err := client.BidiStreaming(context.Background())
		if err != nil {
			log.Println("error while getting stream object for BidiStreaming:", err)
			resMap["Error"] = err
			return resMap
		}

		waits := make(chan struct{})
		go func() {
			for {
				obj, err := bReq.Recv()
				if err == io.EOF {
					resMap["Error"] = nil
					stream.CloseSend()
					close(waits)
					return
				}
				if err != nil {
					log.Println("error occured in BidiStreaming bidi Recv():", err)
					resMap["Error"] = err
					close(waits)
					return
				}
				if err := stream.Send(obj); err != nil {
					log.Println("error while sending obj with stream:", err)
					resMap["Error"] = err
					close(waits)
					return
				}
			}
		}()

		waitc := make(chan struct{})
		go func() {
			for {
				obj, err := stream.Recv()
				if err == io.EOF {
					resMap["Error"] = nil
					close(waitc)
					return
				}
				if err != nil {
					log.Println("erorr occured in BidiStreaming stream Recv():", err)
					resMap["Error"] = err
					close(waitc)
					return
				}
				if sdErr := bReq.Send(obj); sdErr != nil {
					log.Println("error while sending obj with bidi Send():", sdErr)
					resMap["Error"] = sdErr
					close(waitc)
					return
				}
			}
		}()
		<-waitc
		<-waits
		return resMap
	}

	